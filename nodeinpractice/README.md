# List of Node.JS Technique's
### 2.1. Modules
* Technique 1 Installing and loading modules

* Technique 2 Creating and managing modules

* Technique 3 Loading a group of related modules

* Technique 4 Working with paths

### 2.2. Standard I/O and the console object
* Technique 5 Reading and writing to standard I/O

* Technique 6 Logging messages

* Technique 7 Benchmarking a program

### 2.3. Operating system and command-line integration
* Technique 8 Getting platform information

* Technique 9 Passing command-line

* Technique 10 Exiting a program

* Technique 11 Responding to signals

### 2.4. Delaying execution with timers
* Technique 12 Executing functions after a delay with setTimeout 

* Technique 13 Running callbacks periodically with timers 

* Technique 14 Safely managing asynchronous APIs

### 3.1. Changing data encodings
* Technique 15 Converting buffers into other formats 
* Technique 16 Changing string encodings using buffers 

### 3.2. Converting binary files to JSON 
* Technique 17 Using buffers to convert raw data

### 3.3. Creating your own binary protocol 
* Technique 18 Creating your own network protocol

### 4.1. Basic usage 
* Technique 19 Inheriting from EventEmitter 
* Technique 20 Mixing in EventEmitter 

### 4.2. Error handling 
* Technique 21 Managing errors 
* Technique 22 Managing errors with domains 

### 4.3. Advanced patterns 
* Technique 23 Reflection 
* Technique 24 Detecting and exploiting EventEmitter 
* Technique 25 Categorizing event names

### 4.4. Third-party modules and extensions 
* Technique 26 Alternatives to EventEmitter

### 5.2. Built-in streams 
* Technique 27 Using built-in streams to make a static web server 
* Technique 28 Stream error handling 

### 5.3. Third-party modules and streams 
* Technique 29 Using streams from third-party modules 

### 5.4. Using the stream base classes 
* Technique 30 Correctly inheriting from the stream base classes 
* Technique 31 Implementing a readable stream 
* Technique 32 Implementing a writable stream 
* Technique 33 Transmitting and receiving data with duplex streams 
* Technique 34 Parsing data with transform streams

### 5.5. Advanced patterns and optimization 
* Technique 35 Optimizing streams 
* Technique 36 Using the old streams API 
* Technique 37 Adapting streams based on their destination 
* Technique 38 Testing streams 

### 6.1.5. Synchronous alternatives 
* Technique 39 Loading configuration files 
* Technique 40 Using file descriptors 
* Technique 41 Working with file locking 
* Technique 42 Recursive file operations 
* Technique 43 Writing a file database 
* Technique 44 Watching files and directories 

### 7.2. TCP clients and servers 
* Technique 45 Creating a TCP server and tracking clients 
* Technique 46 Testing TCP servers with clients 
* Technique 47 Improve low-latency applications 

### 7.3. UDP clients and servers 
* Technique 48 Transferring a file with UDP 
* Technique 49 UDP client server applications 

### 7.4. HTTP clients and servers 
* Technique 50 HTTP servers 
* Technique 51 Following redirects 
* Technique 52 HTTP proxies 

### 7.5. Making DNS requests 
* Technique 53 Making a DNS request 

### 7.6. Encryption 
* Technique 54 A TCP server that uses encryption 
* Technique 55 Encrypted web servers and clients

### 8.1. Executing external applications 
* Technique 56 Executing external applications 

### 8.1.2. Errors when executing external applications 
* Technique 57 Streaming and external applications 

### 8.1.3. Stringing external applications together 
* Technique 58 Executing commands in a shell 

### 8.1.4. Security and shell command execution 
* Technique 59 Detaching a child process 

### 8.2. Executing Node programs 
* Technique 60 Executing Node programs 
* Technique 61 Forking Node modules 
* Technique 62 Running jobs 

### 8.3. Working synchronously 
* Technique 63 Synchronous child processes

### 9.1. Front-end techniques
* Technique 64 Quick servers for static sites 
* Technique 65 Using the DOM in Node 
* Technique 66 Using Node modules in the browser 

### 9.2. Server-side techniques 
* Technique 67 Express route separation 
* Technique 68 Automatically restarting the server 
* Technique 69 Configuring web applications 
* Technique 70 Elegant error handling 
* Technique 71 RESTful web applications 
* Technique 72 Using custom middleware 
* Technique 73 Using events to decouple functionality 
* Technique 74 Using sessions with WebSockets 
* Technique 75 Migrating Express 3 applications to Express 4 

### 9.3. Testing web applications 
Technique 76 Testing authenticated routes 
Technique 77 Creating seams for middleware injection 
Technique 78 Testing applications that depend on remote services 

### 10.2. Writing simple tests with assertions 
* Technique 79 Writing tests with built-in modules 
* Technique 80 Testing for errors 
* Technique 81 Creating custom assertions 

### 10.3. Test harnesses 
* Technique 82 Organizing tests with a test harness 

### 10.4. Test frameworks 
* Technique 83 Writing tests with Mocha 
* Technique 84 Testing web applications with Mocha 
* Technique 85 The Test Anything Protocol 

### 10.5. Tools for tests 
* Technique 86 Continuous integration 
* Technique 87 Database fixtures

### 11.1.4. The error argument 
* Technique 88 Handling uncaught exceptions 
* Technique 89 Linting Node applications 

### 11.2. Debugging issues 
* Technique 90 Using Nodeâ€™s built-in debugger 
* Technique 91 Using Node Inspector 
* Technique 92 Profiling Node applications 
* Technique 93 Debugging memory leaks 
* Technique 94 Inspecting a running program with a REPL 
* Technique 95 Tracing system calls

### 12.1. Deployment 
* Technique 96 Deploying Node applications to the cloud 
* Technique 97 Using Node with Apache and nginx 
* Technique 98 Safely running Node on port 80 
* Technique 99 Keeping Node processes running 
* Technique 100 Using WebSockets in production

### 12.2. Caching and scaling
* Technique 101 HTTP caching 
* Technique 102 Using a Node proxy for routing and scaling 
* Technique 103 Scaling and resiliency with cluster 

### 12.3. Maintenance 
* Technique 104 Package optimization 
* Technique 105 Logging and logging service

### 13.1.1. A faster Fibonacci module 
* Technique 106 Planning for our module 
* Technique 107 Proving our module idea 

### 13.2. Building out the package.json file 
* Technique 108 Setting up a package.json file 
* Technique 109 Working with dependencies 
* Technique 110 Semantic versioning 

### 13.3. The end user experience 
* Technique 111 Adding executable scripts 
* Technique 112 Trying out a module 
* Technique 113 Testing across multiple Node versions

### 13.4. Publishing 
* Technique 114 Publishing modules 
* Technique 115 Keeping modules private


